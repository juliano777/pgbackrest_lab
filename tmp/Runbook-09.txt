Restore Selected Databases

## Objective
The customer require specific databases to be restored as explained below

## Requirements:

- None but the setup prepared in runbook-07

#There may be cases where it is desirable to selectively restore specific databases from a cluster backup. This could be done for performance reasons or to move selected databases to a machine that does not have enough space to restore the entire cluster backup.
To demonstrate this feature two databases are created: test1 and test2. A fresh backup is run so pgBackRest is aware of the new databases.

#Create two test databases and perform a backup

#On Primary Server

docker exec --user=enterprisedb pgnode1 /usr/lib/edb-as/13/bin/psql -p 5444 -d edb -c "create database test1;"
docker exec --user=enterprisedb pgnode1 /usr/lib/edb-as/13/bin/psql -p 5444 -d edb -c "create database test2;"

# Take incremental backup
docker exec pgbkp1 bash -c "sudo -iu pgbackrest pgbackrest --stanza=demo --type=incr backup"

Each test database will be seeded with tables and data to demonstrate that recovery works with selective restore.
Create a test table in each database

docker exec --user=enterprisedb pgnode1 /usr/lib/edb-as/13/bin/psql -p 5444 -d test1 -c "create table test1_table (id int);"
docker exec --user=enterprisedb pgnode1 /usr/lib/edb-as/13/bin/psql -p 5444 -d test1 -c "insert into test1_table (id) values (1);"

docker exec --user=enterprisedb pgnode1 /usr/lib/edb-as/13/bin/psql -p 5444 -d test2 -c "create table test2_table (id int);"
docker exec --user=enterprisedb pgnode1 /usr/lib/edb-as/13/bin/psql -p 5444 -d test2 -c "insert into test2_table (id) values (1);"

#One of the main reasons to use selective restore is to save space. The size of the test1 database is shown here so it can be compared with the disk utilization after a selective restore.
#Show space used by test1 database

docker exec --user=enterprisedb pgnode1 /usr/lib/edb-as/13/bin/psql -p 5444 -d edb -c "select datname,oid from pg_database;"

root@:~# docker exec --user=enterprisedb pgnode1 /usr/lib/edb-as/13/bin/psql -p 5444 -d edb -c "select datname,oid from pg_database;"
  datname  |  oid
-----------+-------
 postgres  | 15409
 edb       | 15410
 template1 |     1
 template0 | 15408
 testdb    | 16384
 benson    | 16407
 test1     | 16417
 test2     | 16418
(8 rows)

root@:~# docker exec --user=enterprisedb pgnode1 bash -c "du -sh /var/lib/edb/as13/data/base/16417"
13M	/var/lib/edb/as13/data/base/16417

Stop the cluster and restore only the test2 database. Built-in databases ( template0 , template1 , and postgres ) are always restored.
Restore from last backup including only the test2 database

# We are going to perform the restore on the pgrestore server
```bash

docker exec pgrestore apt install sudo

docker exec pgrestore bash -c "chmod 777 /etc/pgbackrest.conf"

docker exec pgrestore bash -c ":> /etc/pgbackrest.conf"

cat << EOF | docker exec -i pgrestore bash
echo "[global]" >> /etc/pgbackrest.conf
echo "repo1-host=pgbkp1" >> /etc/pgbackrest.conf
echo "log-level-console=info" >> /etc/pgbackrest.conf
echo "repo1-host-user=pgbackrest" >> /etc/pgbackrest.conf
echo "log-level-file=debug" >> /etc/pgbackrest.conf
echo "delta=y" >> /etc/pgbackrest.conf

echo "[demo]" >> /etc/pgbackrest.conf
echo "pg1-path=/var/lib/edb/as13/data" >> /etc/pgbackrest.conf
echo "pg1-user=enterprisedb" >> /etc/pgbackrest.conf
echo "pg1-port=5444" >> /etc/pgbackrest.conf
EOF
```
docker exec pgrestore bash -c "cat /etc/pgbackrest.conf"

# Make sure the cluster is clean

```bash
docker exec --user=enterprisedb pgrestore bash -c "/usr/lib/edb-as/13/bin/pg_ctl -D /var/lib/edb/as13/data stop"
docker exec --user=enterprisedb pgrestore bash -c "rm -rf /var/lib/edb/as13/data/*"

```

docker exec --user=enterprisedb pgrestore bash -c "pgbackrest --stanza=demo --delta --db-include=test2 restore"
...


#The following will be seen in the postgresql.auto.conf
#restore_command = 'pgbackrest --stanza=demo archive-get %f "%p"'

docker exec --user=enterprisedb pgnode3 bash -c "cat /var/lib/edb/as13/data/postgresql.auto.conf"

root@ip:~# docker exec --user=enterprisedb pgnode3 bash -c "cat /var/lib/edb/as13/data/postgresql.auto.conf"
# Do not edit this file manually!
# It will be overwritten by the ALTER SYSTEM command.

# Recovery settings generated by pgBackRest restore on 2021-08-25 01:46:09
primary_conninfo = 'host=pgnode1 user=replic_user port=5444'
restore_command = 'pgbackrest --stanza=demo archive-get %f "%p"'

#You will also see the recovery.signal file created the in data directory after the restore is finished. but when the cluster starts, you should not see the file again.

root@ip:~# docker exec --user=enterprisedb pgnode3 bash -c "ls -al /var/lib/edb/as13/data/"
total 152
drwx------ 21 enterprisedb enterprisedb  4096 Aug 25 01:48 .
drwxr-xr-x  3 enterprisedb enterprisedb  4096 Aug 23 02:02 ..
-rw-------  1 enterprisedb enterprisedb     3 Aug 23 02:00 PG_VERSION
-rw-------  1 enterprisedb enterprisedb   262 Aug 25 01:19 backup_label.old
drwx------ 10 enterprisedb enterprisedb  4096 Aug 25 03:12 base
-rw-------  1 enterprisedb enterprisedb    46 Aug 25 01:48 current_logfiles
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:45 dbms_pipe
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:56 global
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:48 log
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:45 pg_commit_ts
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:45 pg_dynshmem
-rw-------  1 enterprisedb enterprisedb  4810 Aug 23 02:00 pg_hba.conf
-rw-------  1 enterprisedb enterprisedb  1636 Aug 23 02:00 pg_ident.conf
drwx------  4 enterprisedb enterprisedb  4096 Aug 25 03:37 pg_logical
drwx------  4 enterprisedb enterprisedb  4096 Aug 25 01:45 pg_multixact
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:45 pg_notify
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:45 pg_replslot
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:45 pg_serial
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:45 pg_snapshots
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:45 pg_stat
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:45 pg_stat_tmp
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:53 pg_subtrans
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:45 pg_tblspc
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:45 pg_twophase
drwx------  3 enterprisedb enterprisedb  4096 Aug 25 03:37 pg_wal
drwx------  2 enterprisedb enterprisedb  4096 Aug 25 01:46 pg_xact
-rw-------  1 enterprisedb enterprisedb   290 Aug 25 01:46 postgresql.auto.conf
-rw-------  1 enterprisedb enterprisedb 32130 Aug 24 04:19 postgresql.conf
-rw-------  1 enterprisedb enterprisedb    66 Aug 25 01:48 postmaster.opts
-rw-------  1 enterprisedb enterprisedb    92 Aug 25 01:48 postmaster.pid
-rw-------  1 enterprisedb enterprisedb     0 Aug 25 01:46 standby.signal
root@ip-172-31-28-189:~#

Start the cluster

docker exec --user=enterprisedb pgrestore bash -c "/usr/lib/edb-as/13/bin/pg_ctl -D /var/lib/edb/as13/data start"

docker exec --user=enterprisedb pgrestore /usr/lib/edb-as/13/bin/psql -p 5444 -d test2 -c "select * from test2_table;"

root@i:~# docker exec --user=enterprisedb pgrestore /usr/lib/edb-as/13/bin/psql -p 5444 -d test2 -c "select * from test2_table;"
 id
----
  1
(1 row)

Once recovery is complete the test2 database will contain all previously created tables and data.

The test1 database, despite successful recovery, is not accessible. This is because the entire database was restored as sparse, zeroed files. PostgreSQL can successfully apply WAL on the zeroed files but the database as a whole will not be valid because key files contain no data. This is purposeful to prevent the database from being accidentally used when it might contain partial data that was applied during WAL replay.

Attempting to connect to the test1 database will produce an error

root@:~# docker exec --user=enterprisedb pgrestore /usr/lib/edb-as/13/bin/psql -p 5444 -d test1 -c "select * from test1_table;"
psql.bin: error: FATAL:  relation mapping file "base/16417/pg_filenode.map" contains invalid data

Since the test1 database is restored with sparse, zeroed files it will only require as much space as the amount of WAL that is written during recovery. While the amount of WAL generated during a backup and applied during recovery can be significant it will generally be a small fraction of the total database size, especially for large databases where this feature is most likely to be useful.

Show space used by test1 database after recovery

root@ip:~# docker exec --user=enterprisedb pgrestore bash -c "du -sh /var/lib/edb/as13/data/base/16417"
16K     /var/lib/edb/as13/data/base/16417

#At this point the only action that can be taken on the invalid test1 database is drop database . pgBackRest does not automatically drop the database since this cannot be done until recovery is complete and the cluster is accessible.
#db-primary â‡’ Drop the test1 database

docker exec --user=enterprisedb pgrestore /usr/lib/edb-as/13/bin/psql -p 5444 -d edb -c "drop database test1;"
DROP DATABASE

#Now that the invalid test1 database has been dropped only the test2 and built-in databases remain.
List remaining databases

docker exec --user=enterprisedb pgrestore /usr/lib/edb-as/13/bin/psql -p 5444 -d edb -c "select oid, datname from pg_database order by oid;"

root@ip:~# docker exec --user=enterprisedb pgrestore /usr/lib/edb-as/13/bin/psql -p 5444 -d edb -c "select oid, datname from pg_database order by oid;"
  oid  |  datname
-------+-----------
     1 | template1
 15408 | template0
 15409 | postgres
 15410 | edb
 16384 | testdb
 16407 | benson
 16418 | test2
(7 rows)
